<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IRC v0.88 - Internet Relay Chat (1988 Edition)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        .crt-screen {
            font-family: 'VT323', monospace;
            background-color: #000000;
            color: #ffffff;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.4);
            height: 100vh;
            width: 100vw;
            margin: 0;
            display: flex;
            flex-direction: column;
            padding: 0; 
            box-sizing: border-box;
            overflow: hidden;
        }
        
        body {
            padding: 0;
            margin: 0;
            background-color: #000;
        }

        * {
            border-radius: 0 !important;
        }

        .msg-user { color: #ffffff; }
        .msg-action { color: #ff00ff; }
        .msg-system { color: #00ffff; }
        .msg-error { color: #ff0000; }
        .msg-warning { color: #ffff00; }
        .msg-friend { color: #00ff00; }

        .nick-color-1 { color: #00ff00; }
        .nick-color-2 { color: #ff00ff; }
        .nick-color-3 { color: #00ffff; }
        .nick-color-4 { color: #ffff00; }
        .nick-color-5 { color: #ff8800; }
        .nick-color-6 { color: #ffffff; }
        .nick-color-7 { color: #aaffaa; }
        .nick-color-8 { color: #ffaa00; }

        .clickable-nick {
            cursor: pointer;
            text-decoration: underline;
        }

        #input-prompt {
            background-color: transparent;
            border: none;
            color: #ffffff;
            outline: none;
            padding: 0;
            flex-grow: 1;
        }

        #status-bar {
            background-color: #000;
            border-top: 2px solid #00ff00;
            padding: 0 0.5rem;
        }
        
        #input-prefix {
            color: #00ff00;
            margin-right: 0.5rem;
        }
        
        .terminal-scroll::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .terminal-scroll::-webkit-scrollbar-thumb {
            background-color: #00ff00;
            border: 1px solid #000;
        }

        .terminal-scroll::-webkit-scrollbar-track {
            background-color: #000;
        }
        
        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .modal-content {
            background-color: #000;
            border: 2px solid #00ff00;
            padding: 1rem;
            box-shadow: 0 0 10px #00ff00;
            max-width: 400px;
            width: 90%;
            font-size: 0.875rem;
        }
    </style>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut, GoogleAuthProvider, signInWithPopup, createUserWithEmailAndPassword, signInWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, where, addDoc, orderBy, setLogLevel, getDocs, deleteDoc, updateDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        let app;
        let db;
        let auth;
        let currentUserId = 'unknown';
        let currentNick = '';
        let currentChannel = '';
        let customNickColorClass = '';
        
        let nickToIdMap = {};
        let friendNicks = [];
        let pendingRequests = [];
        
        let messageUnsubscribe = null;
        let userUnsubscribe = null;
        let friendUnsubscribe = null;
        
        const DEFAULT_CHANNEL = "#GENERAL";
        const MAX_NICK_LENGTH = 15;
        const NICK_TIMEOUT_MS = 60000;
        const ONE_DAY_MS = 86400000;
        
        const RETRO_NICK_COLORS = ['nick-color-1', 'nick-color-2', 'nick-color-3', 'nick-color-4', 'nick-color-5', 'nick-color-6', 'nick-color-7', 'nick-color-8'];

        const CENSORED_WORDS = [
            "badword", "slur", "profanity", "swear", "testfilter" 
        ];

        // --- START: Firebase Configuration (Provided by User) ---
        const firebaseConfig = {
            apiKey: "AIzaSyCvETDgNXGM8YY8lTp1PJcbeE9vPHBdfH8",
            authDomain: "irc25m.firebaseapp.com",
            projectId: "irc25m",
            storageBucket: "irc25m.firebasestorage.app",
            messagingSenderId: "407714149011",
            appId: "1:407714149011:web:276edd445e5c1a03b29366",
            measurementId: "G-58H16BXM67"
        };
        const appId = firebaseConfig.projectId; // Use projectId as the consistent app ID
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        // --- END: Firebase Configuration (Provided by User) ---

        function getFormattedTime(timeMs) {
            const date = timeMs ? new Date(timeMs) : new Date();
            const pad = (n) => n < 10 ? '0' + n : n;
            return `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
        }
        
        function getNickColorClass(id, customColor) {
            if (customColor) return customColor;
            if (!id) return RETRO_NICK_COLORS[0];
            let hash = 0;
            for (let i = 0; i < id.length; i++) {
                hash = id.charCodeAt(i) + ((hash << 5) - hash);
            }
            const index = Math.abs(hash) % RETRO_NICK_COLORS.length;
            return RETRO_NICK_COLORS[index];
        }

        function censorText(text) {
            let censored = text;
            CENSORED_WORDS.forEach(word => {
                const regex = new RegExp(`\\b${word}\\b`, 'gi');
                const mask = '*'.repeat(word.length);
                censored = censored.replace(regex, mask);
            });
            return censored;
        }

        function logSystemMessage(message, type = 'system', channel = currentChannel) {
            const log = document.getElementById('chat-log');
            const time = getFormattedTime();
            const channelPrefix = channel && channel !== currentChannel ? `[${channel}]` : '';
            const messageHtml = `<div class="msg-${type} text-sm leading-tight"><span class="text-green-500">[${time}]</span> * ${channelPrefix}${message}</div>`;
            log.insertAdjacentHTML('beforeend', messageHtml);
            log.scrollTop = log.scrollHeight;
        }

        function getTime() {
            return new Date().getTime();
        }

        function generateRandomNick() {
            const rand = Math.floor(Math.random() * 9000) + 1000;
            return `Guest${rand}`;
        }

        async function handleEmailSignUp(email, password) {
            if (!auth) {
                logSystemMessage("Authentication service not available.", 'error');
                return;
            }
            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                logSystemMessage(`Account created and signed in as ${userCredential.user.email}.`, 'system');
                window.closeSettingsModal();
            } catch (error) {
                logSystemMessage(`Sign up failed: ${error.message}`, 'error');
                console.error("Sign up failed:", error);
            }
        }

        async function handleEmailSignIn(email, password) {
            if (!auth) {
                logSystemMessage("Authentication service not available.", 'error');
                return;
            }
            try {
                const userCredential = await signInWithEmailAndPassword(auth, email, password);
                logSystemMessage(`Signed in as ${userCredential.user.email}.`, 'system');
                window.closeSettingsModal();
            } catch (error) {
                logSystemMessage(`Sign in failed: ${error.message}`, 'error');
                console.error("Sign in failed:", error);
            }
        }

        async function initializeUser(uid) {
            const userRef = getUserDocRef(uid);
            const userDoc = await getDoc(userRef); 
            
            const userData = userDoc.exists() ? userDoc.data() : {};
            
            currentNick = userData.nick || generateRandomNick();
            customNickColorClass = userData.customNickColor || '';

            updateUserPresence(currentNick);
            joinChannel(DEFAULT_CHANNEL);

            friendUnsubscribe = listenForFriendsAndRequests();
            
            const authStatusText = document.getElementById('auth-status-text');
            if (auth.currentUser) {
                authStatusText.textContent = auth.currentUser.isAnonymous 
                    ? "Guest (Anonymous)" 
                    : auth.currentUser.email || "Authenticated";
            } else {
                 authStatusText.textContent = "Signed Out";
            }
        }

        async function initFirebase() {
            if (!firebaseConfig) {
                logSystemMessage("Firebase Config is missing. Cannot connect.", 'error');
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                setLogLevel('Debug');

                await new Promise((resolve, reject) => {
                    const unsubscribe = onAuthStateChanged(auth, async (user) => {
                        unsubscribe();
                        if (user) {
                            currentUserId = user.uid;
                            await initializeUser(user.uid); 
                            resolve();
                        } else {
                            try {
                                if (initialAuthToken) {
                                    const cred = await signInWithCustomToken(auth, initialAuthToken);
                                    currentUserId = cred.user.uid;
                                    logSystemMessage("Authenticated successfully using secure token.", 'system');
                                } else {
                                    const cred = await signInAnonymously(auth);
                                    currentUserId = cred.user.uid;
                                    logSystemMessage("Signed in as Guest (Anonymous Auth).", 'system');
                                }
                                await initializeUser(currentUserId);
                                resolve();
                            } catch (e) {
                                logSystemMessage(`Authentication failed: ${e.message}`, 'error');
                                reject(e);
                            }
                        }
                    });
                });
            } catch (error) {
                logSystemMessage(`Firebase initialization error: ${error.message}`, 'error');
                console.error("Firebase init error:", error);
            }
        }
        
        async function handleSignOut() {
            if (messageUnsubscribe) messageUnsubscribe();
            if (userUnsubscribe) userUnsubscribe();
            if (friendUnsubscribe) friendUnsubscribe();
            
            try {
                await signOut(auth);
                
                currentUserId = 'unknown';
                currentNick = 'Disconnected';
                currentChannel = '';
                customNickColorClass = '';
                
                document.getElementById('chat-log').innerHTML = '';
                document.getElementById('user-list').innerHTML = '';
                document.getElementById('friend-list').innerHTML = '';
                document.getElementById('request-list').innerHTML = '';
                document.getElementById('channel-name').textContent = '*** DISCONNECTED ***';
                document.getElementById('status-text').textContent = 'Signed Out';
                document.getElementById('input-prefix-nick').textContent = '[SIGNED OUT]';
                document.getElementById('auth-status-text').textContent = "Signed Out";
                
                logSystemMessage("You have been signed out. Please reload to sign in as a new guest.", 'system');
                
            } catch (error) {
                logSystemMessage(`Error signing out: ${error.message}`, 'error');
            }
        }
        
        async function signInWithGoogle() {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
                window.closeSettingsModal();
            } catch (error) {
                if (error.code === 'auth/popup-closed-by-user') {
                    logSystemMessage("Google sign-in popup closed.", 'warning');
                } else {
                    logSystemMessage(`Google sign-in failed: ${error.message}`, 'error');
                    console.error("Google sign-in failed:", error);
                }
            }
        }

        function getUserDocRef(uid) {
            return doc(db, 'artifacts', appId, 'public', 'data', 'users', uid);
        }

        function getChannelDocRef(channelName) {
            return doc(db, 'artifacts', appId, 'public', 'data', 'channels', channelName);
        }

        function getMessagesCollectionRef() {
            return collection(db, 'artifacts', appId, 'public', 'data', 'messages');
        }

        function getFriendRequestsCollectionRef() {
            return collection(db, 'artifacts', appId, 'public', 'data', 'friendRequests');
        }

        async function updateChannelActivity(channelName) {
             if (!db || !channelName) return;
             const channelRef = getChannelDocRef(channelName);
             try {
                 await setDoc(channelRef, {
                     channelName: channelName,
                     last_active: getTime(),
                 }, { merge: true });
             } catch (e) {
                 console.error("Error updating channel activity:", e);
             }
        }

        async function updateUserPresence(newNick = currentNick) {
            if (!currentUserId || !db) return;
            
            const userRef = getUserDocRef(currentUserId);
            try {
                await setDoc(userRef, {
                    userId: currentUserId,
                    nick: newNick,
                    customNickColor: customNickColorClass,
                    channel: currentChannel,
                    last_active: getTime(), 
                }, { merge: true });

                currentNick = newNick;
                document.getElementById('input-prefix-nick').textContent = currentChannel ? `${currentChannel} [${currentNick}]` : `[${currentNick}]`;
                
            } catch (e) {
                console.error("Error updating user presence:", e);
                logSystemMessage(`Error updating Nick: ${newNick}`, 'error');
            }
        }
        
        async function saveUserSettings(newNick, newColor) {
            if (!currentUserId || !db) return;
            
            newNick = newNick.trim();
            if (newNick.length === 0 || newNick.length > MAX_NICK_LENGTH) {
                logSystemMessage(`Nickname must be between 1 and ${MAX_NICK_LENGTH} characters.`, 'error');
                return;
            }

            const oldNick = currentNick;
            const userRef = getUserDocRef(currentUserId);
            
            try {
                await setDoc(userRef, {
                    nick: newNick,
                    customNickColor: newColor,
                }, { merge: true });

                customNickColorClass = newColor;
                if (oldNick !== newNick) {
                    logSystemMessage(`*** ${oldNick} is now known as ${newNick}`, 'system');
                }
                updateUserPresence(newNick);
                window.closeSettingsModal();

            } catch (e) {
                console.error("Error saving settings:", e);
                logSystemMessage("Failed to save settings.", 'error');
            }
        }


        async function sendMessage(text, type = 'message') {
            if (!currentNick || !currentChannel) {
                logSystemMessage("You must join a channel before chatting (e.g., /join #general).", 'error');
                return;
            }
            
            const censoredText = censorText(text);

            await updateUserPresence();
            await updateChannelActivity(currentChannel);

            try {
                await addDoc(getMessagesCollectionRef(), {
                    time: getTime(),
                    channel: currentChannel,
                    nick: currentNick,
                    userId: currentUserId,
                    text: censoredText, 
                    type: type, 
                });
            } catch (e) {
                console.error("Error sending message: ", e);
                logSystemMessage("Failed to send message.", 'error');
            }
        }
        
        function joinChannel(channelName) {
            if (!channelName || channelName.length < 2 || !channelName.startsWith('#')) {
                logSystemMessage(`Invalid channel name: ${channelName}. Must start with '#'.`, 'error');
                return;
            }

            if (currentChannel) {
                 logSystemMessage(`*** ${currentNick} has left ${currentChannel}`, 'system', currentChannel);
            }
            
            if (messageUnsubscribe) messageUnsubscribe();
            if (userUnsubscribe) userUnsubscribe();
            
            currentChannel = channelName;
            
            document.getElementById('chat-log').innerHTML = '';
            document.getElementById('channel-name').textContent = currentChannel;
            document.getElementById('topic-content').textContent = `Now viewing channel ${currentChannel}.`;
            document.getElementById('input-prefix-nick').textContent = `${currentChannel} [${currentNick}]`;
            
            messageUnsubscribe = listenForMessages(currentChannel);
            userUnsubscribe = listenForUsers(currentChannel);
            
            updateUserPresence();
            updateChannelActivity(currentChannel);
            logSystemMessage(`*** ${currentNick} has joined ${currentChannel}`, 'system', currentChannel);
        }

        function getUserIdByNick(nick) {
            for (const id in nickToIdMap) {
                if (nickToIdMap[id].nick.toLowerCase() === nick.toLowerCase()) {
                    return id;
                }
            }
            return null;
        }

        function listenForFriendsAndRequests() {
            if (!db || !currentUserId) return;
            
            const friendsRef = getFriendRequestsCollectionRef();
            
            const acceptedFriendsListener = (snapshot) => {
                const friendList = document.getElementById('friend-list');
                const friendsMap = new Map();

                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const friendId = data.senderId === currentUserId ? data.receiverId : data.senderId;
                    const friendNick = data.senderId === currentUserId ? data.receiverNick : data.senderNick;
                    
                    friendsMap.set(friendId, friendNick);
                });

                friendNicks = Array.from(friendsMap.values());

                friendList.innerHTML = friendNicks
                    .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
                    .map(nick => 
                        `<div><span class="text-green-500">${nick}</span></div>`
                    ).join('');
            };

            const q2a = query(friendsRef, where('senderId', '==', currentUserId), where('status', '==', 'accepted'));
            onSnapshot(q2a, acceptedFriendsListener);

            const q2b = query(friendsRef, where('receiverId', '==', currentUserId), where('status', '==', 'accepted'));
            onSnapshot(q2b, acceptedFriendsListener);

            const q1 = query(friendsRef, where('receiverId', '==', currentUserId), where('status', '==', 'pending'));
            return onSnapshot(q1, (snapshot) => {
                const requestList = document.getElementById('request-list');
                pendingRequests = [];

                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    pendingRequests.push({ 
                        id: data.senderId, 
                        nick: data.senderNick, 
                        docId: doc.id
                    });
                });

                document.getElementById('request-count').textContent = pendingRequests.length;
                
                requestList.innerHTML = pendingRequests
                    .map(req => 
                        `<div><span class="text-yellow-400">${req.nick}</span> (use /accept ${req.nick})</div>`
                    ).join('');
            });
        }


        function listenForMessages(channel) {
            if (!db) return;

            const q = query(
                getMessagesCollectionRef(), 
                where('channel', '==', channel), 
                orderBy('time', 'asc')
            );
            
            return onSnapshot(q, (snapshot) => {
                const log = document.getElementById('chat-log');
                
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added") {
                        const data = change.doc.data();
                        renderMessage(data);
                    }
                });
                
                log.scrollTop = log.scrollHeight;
            });
        }

        function listenForUsers(channel) {
            if (!db) return;

            const usersRef = collection(db, 'artifacts', appId, 'public', 'data', 'users');
            const cutoff = getTime() - NICK_TIMEOUT_MS;
            
            const q = query(
                usersRef, 
                where('channel', '==', channel),
                where('last_active', '>=', cutoff)
            );

            return onSnapshot(q, (snapshot) => {
                const userList = document.getElementById('user-list');
                const activeUsers = [];
                nickToIdMap = {};

                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    const finalColor = getNickColorClass(data.userId, data.customNickColor);
                    activeUsers.push({ id: data.userId, nick: data.nick, colorClass: finalColor, channel: data.channel });
                    
                    nickToIdMap[data.userId] = { 
                        nick: data.nick, 
                        color: finalColor, 
                        channel: data.channel,
                        isAnonymous: data.userId === auth.currentUser?.uid ? auth.currentUser.isAnonymous : undefined
                    };
                });

                userList.innerHTML = activeUsers
                    .sort((a, b) => a.nick.toLowerCase().localeCompare(b.toLowerCase()))
                    .map(user => 
                        `<div><span class="${user.colorClass} clickable-nick" data-user-id="${user.id}">${user.nick}</span></div>`
                    ).join('');
                
                document.querySelectorAll('#user-list .clickable-nick').forEach(span => {
                    span.onclick = (e) => window.openProfileModal(e.target.dataset.userId);
                });

                const statusText = document.getElementById('status-text');
                statusText.innerHTML = 
                    `<span class="text-white">1:${currentChannel}</span> <span class="text-green-500">(${activeUsers.length} users)</span>`;
            });
            
            setInterval(() => {
                if (currentNick && currentChannel) {
                    updateUserPresence();
                }
            }, NICK_TIMEOUT_MS / 3);
        }


        function renderMessage(data) {
            const log = document.getElementById('chat-log');
            const time = getFormattedTime(data.time);
            
            const userData = nickToIdMap[data.userId] || { color: getNickColorClass(data.userId) };
            const nickColorClass = userData.color;
            let messageHtml = '';

            if (data.type === 'message') {
                messageHtml = `<div class="msg-user text-sm leading-tight"><span class="text-green-500">[${time}]</span> <span class="${nickColorClass}">${data.nick}</span>: ${data.text}</div>`;
            } else if (data.type === 'action') {
                messageHtml = `<div class="msg-action text-sm leading-tight"><span class="text-green-500">[${time}]</span> * ${data.nick} ${data.text}</div>`;
            }

            log.insertAdjacentHTML('beforeend', messageHtml);
        }
        
        window.openSettingsModal = function() {
            document.getElementById('settings-nick-input').value = currentNick;
            
            const colorPicker = document.getElementById('settings-color-picker');
            colorPicker.innerHTML = RETRO_NICK_COLORS.map(colorClass => 
                `<button type="button" data-color-class="${colorClass}" 
                        class="color-option p-2 w-8 h-8 mr-2 mb-2 border border-green-500 ${colorClass} 
                        ${colorClass === customNickColorClass ? 'border-4' : ''}" 
                        onclick="selectColor('${colorClass}')"></button>`
            ).join('');
            
            document.getElementById('settings-selected-color').value = customNickColorClass;
            
            document.getElementById('settings-modal').classList.remove('hidden');
        }

        window.closeSettingsModal = function() {
            document.getElementById('settings-modal').classList.add('hidden');
        }
        
        window.selectColor = function(colorClass) {
            document.querySelectorAll('#settings-color-picker .color-option').forEach(btn => {
                btn.classList.remove('border-4');
                if (btn.dataset.colorClass === colorClass) { 
                    btn.classList.add('border-4');
                }
            });
            document.getElementById('settings-selected-color').value = colorClass;
        }

        window.openProfileModal = function(userId) {
            const userData = nickToIdMap[userId];
            
            if (!userData) {
                logSystemMessage("Could not retrieve user profile data. They might have just logged out.", 'error');
                return;
            }
            
            const profileNick = document.getElementById('profile-nick');
            const profileId = document.getElementById('profile-id');
            const profileChannel = document.getElementById('profile-channel');

            profileNick.className = `text-2xl font-bold ${userData.color}`;
            profileNick.textContent = userData.nick;
            profileId.textContent = userId;
            profileChannel.textContent = userData.channel;

            document.getElementById('profile-modal').classList.remove('hidden');
        }

        window.closeProfileModal = function() {
            document.getElementById('profile-modal').classList.add('hidden');
        }


        function handleCommand(input) {
            const parts = input.trim().split(/\s+/);
            const command = parts[0].toLowerCase();
            const targetNick = parts[1] || '';
            const rest = parts.slice(1).join(' ').trim();
            
            document.getElementById('input-prompt').value = '';

            if (command.startsWith('/')) {
                const cmd = command.substring(1);
                
                switch (cmd) {
                    case 'nick':
                        logSystemMessage("Use the [SETTINGS] button to change your nickname.", 'warning');
                        break;

                    case 'me':
                        if (rest.length > 0) {
                            sendMessage(rest, 'action');
                        } else {
                            logSystemMessage("Usage: /me <action text>", 'error');
                        }
                        break;
                        
                    case 'join':
                        if (rest.length > 0 && rest.startsWith('#')) {
                            joinChannel(rest.toUpperCase()); 
                        } else {
                            logSystemMessage("Usage: /join #channelname. Channel name must start with '#'.", 'error');
                        }
                        break;
                        
                    case 'list':
                        if (!db) {
                            logSystemMessage("Error: Database not ready.", 'error');
                            break;
                        }
                        const cutoff = getTime() - ONE_DAY_MS;
                        const channelsRef = collection(db, 'artifacts', appId, 'public', 'data', 'channels');
                        const q = query(channelsRef, where('last_active', '>=', cutoff));
                        
                        getDocs(q).then(snapshot => {
                             logSystemMessage("--- Active Channels (Inactivity < 24h) ---", 'system');
                             if (snapshot.empty) {
                                 logSystemMessage("No active channels found. Be the first! Use /join #newchannel", 'system');
                                 return;
                             }
                             snapshot.docs.forEach(doc => {
                                 const data = doc.data();
                                 logSystemMessage(`${data.channelName} (Last active: ${getFormattedTime(data.last_active)})`, 'system');
                             });
                             logSystemMessage("--- End of Channel List ---", 'system');
                        }).catch(e => {
                            logSystemMessage("Error fetching channel list.", 'error');
                            console.error("Error fetching channel list:", e);
                        });
                        break;
                    
                    case 'friend':
                        handleFriendRequest(targetNick, 'send');
                        break;

                    case 'accept':
                        handleFriendRequest(targetNick, 'accept');
                        break;

                    case 'deny':
                        handleFriendRequest(targetNick, 'deny');
                        break;

                    case 'unfriend':
                        handleFriendRequest(targetNick, 'unfriend');
                        break;

                    case 'help':
                        logSystemMessage("--- IRCD Commands ---", 'system');
                        logSystemMessage("Use [SETTINGS] for /nick and color customization.", 'system');
                        logSystemMessage("/me <action> - Perform an action.", 'system');
                        logSystemMessage("/join #name - Join a channel (creates if new).", 'system');
                        logSystemMessage("/list - List channels active in the last 24h.", 'system');
                        logSystemMessage("/friend <nick> - Send a friend request.", 'system');
                        logSystemMessage("/accept <nick> - Accept a friend request.", 'system');
                        logSystemMessage("/deny <nick> - Deny a friend request.", 'system');
                        logSystemMessage("/unfriend <nick> - Remove a friend.", 'system');
                        logSystemMessage("--- End of Help ---", 'system');
                        break;
                        
                    default:
                        logSystemMessage(`*** Unknown command: ${command}`, 'error');
                        break;
                }
            } else {
                if (input.trim().length > 0) {
                    sendMessage(input);
                }
            }
        }

        async function handleFriendRequest(targetNick, action) {
            if (!targetNick) {
                logSystemMessage(`Usage: /${action} <nickname>`, 'error');
                return;
            }
            if (targetNick.toLowerCase() === currentNick.toLowerCase()) {
                 logSystemMessage("You cannot perform this action on yourself.", 'error');
                return;
            }
            
            const targetId = getUserIdByNick(targetNick);
            if (!targetId) {
                logSystemMessage(`User ${targetNick} not found or is offline.`, 'error');
                return;
            }

            const friendsRef = getFriendRequestsCollectionRef();

            try {
                if (action === 'send') {
                    const qCheck = query(friendsRef, 
                        where('status', 'in', ['pending', 'accepted']),
                        where('senderNick', 'in', [currentNick, targetNick]),
                        where('receiverNick', 'in', [currentNick, targetNick])
                    );
                    const existing = await getDocs(qCheck);

                    if (!existing.empty) {
                        logSystemMessage(`You already have a pending or active friendship with ${targetNick}.`, 'warning');
                        return;
                    }

                    await addDoc(friendsRef, {
                        senderId: currentUserId,
                        receiverId: targetId,
                        senderNick: currentNick,
                        receiverNick: targetNick,
                        status: 'pending',
                        time: getTime()
                    });
                    logSystemMessage(`Friend request sent to ${targetNick}.`, 'msg-friend');

                } else if (action === 'accept' || action === 'deny') {
                    const q = query(friendsRef, 
                        where('senderId', '==', targetId), 
                        where('receiverId', '==', currentUserId), 
                        where('status', '==', 'pending')
                    );
                    const requestSnapshot = await getDocs(q);

                    if (requestSnapshot.empty) {
                        logSystemMessage(`No pending request found from ${targetNick}.`, 'error');
                        return;
                    }

                    const docRef = requestSnapshot.docs[0].ref;
                    
                    if (action === 'accept') {
                        await updateDoc(docRef, { status: 'accepted' });
                        logSystemMessage(`You are now friends with ${targetNick}!`, 'msg-friend');
                    } else {
                        await deleteDoc(docRef);
                        logSystemMessage(`Request from ${targetNick} denied.`, 'msg-friend');
                    }

                } else if (action === 'unfriend') {
                    const qA = query(friendsRef, where('senderId', '==', currentUserId), where('receiverId', '==', targetId), where('status', '==', 'accepted'));
                    const qB = query(friendsRef, where('senderId', '==', targetId), where('receiverId', '==', currentUserId), where('status', '==', 'accepted'));

                    const [snapA, snapB] = await Promise.all([getDocs(qA), getDocs(qB)]);
                    const docToDelete = snapA.empty ? (snapB.empty ? null : snapB.docs[0].ref) : snapA.docs[0].ref;

                    if (docToDelete) {
                        await deleteDoc(docToDelete);
                        logSystemMessage(`You have unfriended ${targetNick}.`, 'msg-friend');
                    } else {
                        logSystemMessage(`You are not currently friends with ${targetNick}.`, 'error');
                    }
                }
            } catch (e) {
                console.error(`Error during friend action (${action}):`, e);
                logSystemMessage(`A database error occurred during /${action}.`, 'error');
            }
        }


        window.onload = () => {
            const inputPrompt = document.getElementById('input-prompt');
            inputPrompt.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const input = inputPrompt.value;
                    if (input) {
                        handleCommand(input);
                    }
                }
            });
            
            // Event listener for the SETTINGS button
            document.getElementById('settings-btn').onclick = window.openSettingsModal;
            
            document.getElementById('save-settings-btn').onclick = () => {
                const newNick = document.getElementById('settings-nick-input').value;
                const newColor = document.getElementById('settings-selected-color').value || customNickColorClass; 
                saveUserSettings(newNick, newColor);
            };
            
            document.getElementById('sign-out-btn').onclick = handleSignOut;
            
            document.getElementById('google-sign-in-btn').onclick = signInWithGoogle;
            
            document.getElementById('email-sign-up-btn').onclick = () => {
                const email = document.getElementById('settings-email-input').value;
                const password = document.getElementById('settings-password-input').value;
                handleEmailSignUp(email, password);
            };

            document.getElementById('email-sign-in-btn').onclick = () => {
                const email = document.getElementById('settings-email-input').value;
                const password = document.getElementById('settings-password-input').value;
                handleEmailSignIn(email, password);
            };


            initFirebase();
        };

    </script>
</head>
<body class="bg-black">

    <div id="irc-app" class="crt-screen">
        
        <div class="w-full text-xs text-center border-b border-green-500 py-1 bg-gray-900 text-green-500">
            IRC v0.88 - Multi-Channel Client | Click a Nickname to view profile!
        </div>
        
        <div class="flex flex-grow overflow-hidden text-sm">
            
            <div class="w-1/4 max-w-[200px] pl-1 pt-1 flex flex-col border-r border-green-500">
                 <div id="channel-name" class="text-sm font-bold pb-1 text-green-500 leading-tight">*** connecting ***</div>
                 <div class="text-xs text-white pb-1 leading-tight border-b border-green-500">TOPIC</div>
                 <div id="topic-content" class="text-xs text-cyan-400 pt-1 leading-tight terminal-scroll overflow-y-auto">
                    Awaiting server connection...
                 </div>
            </div>

            <div id="chat-log" class="terminal-scroll flex-grow overflow-y-auto px-1 pt-1 w-1/2" style="height: 100%;">
                <div class="msg-system text-sm leading-tight"><span class="text-green-500">[SYSTEM]</span> Connecting to server IRCD-0.88...</div>
                <div class="msg-system text-sm leading-tight"><span class="text-green-500">[SYSTEM]</span> Authenticating with custom token...</div>
            </div>

            <div class="w-1/4 min-w-[150px] pl-1 pt-1 border-l border-green-500 flex flex-col overflow-hidden">
                
                <div class="text-sm font-bold pb-1 text-green-500 border-b border-green-500 leading-tight">Users in Channel</div>
                <div id="user-list" class="terminal-scroll overflow-y-auto pt-1 text-sm leading-tight h-1/3 min-h-[50px] max-h-[150px]">
                </div>

                <div class="text-sm font-bold pt-2 pb-1 text-green-500 border-t border-green-500 leading-tight">Friends</div>
                <div id="friend-list" class="terminal-scroll overflow-y-auto pt-1 text-sm leading-tight h-1/3 min-h-[50px] max-h-[150px]">
                </div>

                <div class="text-sm font-bold pt-2 pb-1 text-green-500 border-t border-green-500 leading-tight">Requests (<span id="request-count">0</span>)</div>
                <div id="request-list" class="terminal-scroll overflow-y-auto pt-1 text-sm leading-tight flex-grow">
                </div>
            </div>
        </div>

        <div id="status-bar" class="w-full h-8 flex items-center text-sm px-1 leading-tight">
            
            <button id="settings-btn" class="text-green-500 pr-3 whitespace-nowrap min-w-[15%] h-full flex items-center justify-center border-r border-green-500 hover:text-white transition-colors">
                [SETTINGS]
            </button>

            <div id="status-text" class="text-green-500 pr-3 whitespace-nowrap min-w-[20%] border-r border-green-500 h-full flex items-center justify-center">
            </div>
            
            <div id="input-container" class="flex flex-grow items-center h-full pl-3">
                <span id="input-prefix-nick" class="text-green-500 pr-1">***</span>
                <input type="text" id="input-prompt" placeholder="Type message or /command" maxlength="255">
            </div>
        </div>
        
    </div>
    
    <div id="settings-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-xl font-bold text-green-500 mb-4">USER SETTINGS & AUTHENTICATION</h2>

            <!-- Nickname & Color Settings -->
            <div class="mb-4">
                <label for="settings-nick-input" class="block text-cyan-400 mb-1">Nickname:</label>
                <input type="text" id="settings-nick-input" maxlength="15" class="w-full bg-black border border-green-500 text-white p-1 focus:outline-none focus:ring-0">
            </div>

            <div class="mb-4">
                <label class="block text-cyan-400 mb-1">Name Color:</label>
                <div id="settings-color-picker" class="flex flex-wrap">
                </div>
                <input type="hidden" id="settings-selected-color">
            </div>
            
            <div class="mb-4 pt-4 border-t border-green-500">
                <div class="text-xs text-yellow-400 mb-2">Auth Status: <span id="auth-status-text">Connecting...</span></div>

                <!-- Email/Password Inputs -->
                <label for="settings-email-input" class="block text-cyan-400 mb-1 text-xs">Email:</label>
                <input type="email" id="settings-email-input" class="w-full bg-black border border-green-500 text-white p-1 mb-2 text-sm focus:outline-none focus:ring-0" placeholder="user@example.com">
                
                <label for="settings-password-input" class="block text-cyan-400 mb-1 text-xs">Password:</label>
                <input type="password" id="settings-password-input" class="w-full bg-black border border-green-500 text-white p-1 mb-2 text-sm focus:outline-none focus:ring-0" placeholder="Minimum 6 characters">

                <!-- Email/Password Buttons -->
                <div class="flex space-x-2 mb-4">
                    <button id="email-sign-up-btn" class="w-1/2 bg-cyan-700 text-white py-1 px-2 border border-cyan-700 hover:bg-black hover:text-cyan-500 transition-colors text-xs">
                        CREATE ACCOUNT
                    </button>
                    <button id="email-sign-in-btn" class="w-1/2 bg-cyan-700 text-white py-1 px-2 border border-cyan-700 hover:bg-black hover:text-cyan-500 transition-colors text-xs">
                        SIGN IN
                    </button>
                </div>
                
                <!-- Google Sign In -->
                <div class="flex items-center my-3">
                    <div class="flex-grow border-t border-gray-700"></div>
                    <span class="flex-shrink mx-4 text-gray-500 text-xs">OR</span>
                    <div class="flex-grow border-t border-gray-700"></div>
                </div>

                <button id="google-sign-in-btn" class="mt-2 w-full bg-blue-700 text-white py-1 px-4 border border-blue-700 hover:bg-black hover:text-blue-500 transition-colors">
                    SIGN IN WITH GOOGLE
                </button>
            </div>

            <div class="flex justify-between items-center pt-2 border-t border-green-500">
                <button id="save-settings-btn" class="bg-green-500 text-black py-1 px-4 border border-green-500 hover:bg-black hover:text-green-500 transition-colors">
                    SAVE
                </button>
                <button onclick="closeSettingsModal()" class="text-red-500 py-1 px-4 hover:text-white transition-colors">
                    CANCEL
                </button>
                <button id="sign-out-btn" class="text-red-500 py-1 px-4 border border-red-500 hover:bg-red-500 hover:text-black transition-colors">
                    SIGN OUT
                </button>
            </div>
        </div>
    </div>
    
    <div id="profile-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 class="text-xl font-bold text-green-500 mb-4">USER PROFILE</h2>

            <div class="mb-4 border-b border-green-500 pb-2">
                <div id="profile-nick" class="text-2xl font-bold nick-color-1"></div>
            </div>

            <div class="mb-2">
                <span class="text-cyan-400">Current Channel:</span> <span id="profile-channel" class="text-white"></span>
            </div>
            
            <div class="mb-4">
                <span class="text-cyan-400">User ID:</span> 
                <div id="profile-id" class="text-white text-xs break-all mt-1 p-1 bg-gray-900 border border-green-500"></div>
            </div>

            <div class="flex justify-end pt-2">
                <button onclick="closeProfileModal()" class="bg-green-500 text-black py-1 px-4 border border-green-500 hover:bg-black hover:text-green-500 transition-colors">
                    CLOSE
                </button>
            </div>
        </div>
    </div>
</body>
</html>
